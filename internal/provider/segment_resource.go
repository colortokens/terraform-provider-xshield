// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-log/tflog"

	tfTypes "github.com/colortokens/terraform-provider-xshield/internal/provider/types"
	"github.com/colortokens/terraform-provider-xshield/internal/sdk"
	"github.com/colortokens/terraform-provider-xshield/internal/sdk/models/operations"
	"github.com/colortokens/terraform-provider-xshield/internal/sdk/models/shared"
	speakeasy_objectvalidators "github.com/colortokens/terraform-provider-xshield/internal/validators/objectvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &SegmentResource{}
var _ resource.ResourceWithImportState = &SegmentResource{}

func NewSegmentResource() resource.Resource {
	return &SegmentResource{}
}

// SegmentResource defines the resource implementation.
type SegmentResource struct {
	client *sdk.Xshield
}

// SegmentResourceModel describes the resource data model.
type SegmentResourceModel struct {
	AutoSynchronizeEnabled               types.Bool                              `tfsdk:"auto_synchronize_enabled"`
	BaselineBreachImpactScore            types.Int64                             `tfsdk:"baseline_breach_impact_score"`
	BaselineMatchingAssets               types.Int64                             `tfsdk:"baseline_matching_assets"`
	Criteria                             types.String                            `tfsdk:"criteria"`
	Description                          types.String                            `tfsdk:"description"`
	ID                                   types.String                            `tfsdk:"id"`
	LowestInboundPolicyStatus            types.String                            `tfsdk:"lowest_inbound_policy_status"`
	LowestOutboundPolicyStatus           types.String                            `tfsdk:"lowest_outbound_policy_status"`
	LowestProgressiveInboundPolicyStatus types.String                            `tfsdk:"lowest_progressive_inbound_policy_status"`
	MatchingAssets                       types.Int64                             `tfsdk:"matching_assets"`
	Milestones                           []tfTypes.TagBasedPolicyMilestone       `tfsdk:"milestones"`
	Namednetworks                        []tfTypes.MetadataNamedNetworkReference `tfsdk:"namednetworks"`
	PolicyAutomationConfigurable         types.Bool                              `tfsdk:"policy_automation_configurable"`
	TagBasedPolicyName                   types.String                            `tfsdk:"tag_based_policy_name"`
	TargetBreachImpactScore              types.Int64                             `tfsdk:"target_breach_impact_score"`
	Templates                            []tfTypes.TemplateReference             `tfsdk:"templates"`
	Timeline                             types.Int64                             `tfsdk:"timeline"`
}

func (r *SegmentResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_segment"
}

func (r *SegmentResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Segment Resource",
		Attributes: map[string]schema.Attribute{
			"auto_synchronize_enabled": schema.BoolAttribute{
				Computed: true,
			},
			"baseline_breach_impact_score": schema.Int64Attribute{
				Computed: true,
			},
			"baseline_matching_assets": schema.Int64Attribute{
				Computed: true,
			},
			"criteria": schema.StringAttribute{
				Computed: true,
				Optional: true,
				// Note: The API might modify the criteria by adding additional conditions
				// For example, it might add "AND 'managedby' in ('colortokens')" to the criteria
			},
			"description": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(1000),
				},
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"lowest_inbound_policy_status": schema.StringAttribute{
				Computed: true,
			},
			"lowest_outbound_policy_status": schema.StringAttribute{
				Computed: true,
			},
			"lowest_progressive_inbound_policy_status": schema.StringAttribute{
				Computed: true,
			},
			"matching_assets": schema.Int64Attribute{
				Computed: true,
			},
			"milestones": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"completion_percentage": schema.NumberAttribute{
							Computed: true,
						},
						"milestone_id": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"namednetworks": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"named_network_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
						"named_network_name": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
					},
				},
			},
			"policy_automation_configurable": schema.BoolAttribute{
				Computed: true,
			},
			"tag_based_policy_name": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(256),
				},
			},
			"target_breach_impact_score": schema.Int64Attribute{
				Computed: true,
				Optional: true,
				Validators: []validator.Int64{
					int64validator.AtMost(100),
				},
			},
			"templates": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"template_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
						"template_name": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
					},
				},
			},
			"timeline": schema.Int64Attribute{
				Computed: true,
				Optional: true,
				Validators: []validator.Int64{
					int64validator.AtLeast(1),
				},
			},
		},
	}
}

func (r *SegmentResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Xshield)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Xshield, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SegmentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *SegmentResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedTagBasedPolicy()
	res, err := r.client.Tagbasedpolicies.CreateTagBasedPolicy(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 202 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.TagBasedPolicyResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedTagBasedPolicyResponse(res.TagBasedPolicyResponse)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SegmentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *SegmentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save the current values of fields we want to preserve
	targetBreachImpactScore := data.TargetBreachImpactScore
	timeline := data.Timeline
	criteria := data.Criteria

	var tagbasedpolicyID string
	tagbasedpolicyID = data.ID.ValueString()

	request := operations.GetTagBasedPolicyRequest{
		TagbasedpolicyID: tagbasedpolicyID,
	}
	res, err := r.client.Tagbasedpolicies.GetTagBasedPolicy(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.TagBasedPolicyResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedTagBasedPolicyResponse(res.TagBasedPolicyResponse)

	// Set computed fields to null
	data.AutoSynchronizeEnabled = types.BoolNull()
	data.BaselineBreachImpactScore = types.Int64Null()
	data.BaselineMatchingAssets = types.Int64Null()
	data.LowestInboundPolicyStatus = types.StringNull()
	data.LowestOutboundPolicyStatus = types.StringNull()
	data.LowestProgressiveInboundPolicyStatus = types.StringNull()
	data.MatchingAssets = types.Int64Null()
	data.Milestones = []tfTypes.TagBasedPolicyMilestone{}
	data.PolicyAutomationConfigurable = types.BoolNull()

	// Restore preserved fields
	data.TargetBreachImpactScore = targetBreachImpactScore
	data.Timeline = timeline
	data.Criteria = criteria

	// Only set namednetwork_name to null if it's not returned by the API
	for i := range data.Namednetworks {
		if data.Namednetworks[i].NamedNetworkName.IsNull() || data.Namednetworks[i].NamedNetworkName.ValueString() == "" {
			data.Namednetworks[i].NamedNetworkName = types.StringNull()
		}
	}

	// Only set template_name to null if it's not returned by the API
	for i := range data.Templates {
		if data.Templates[i].TemplateName.IsNull() || data.Templates[i].TemplateName.ValueString() == "" {
			data.Templates[i].TemplateName = types.StringNull()
		}
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SegmentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var planData *SegmentResourceModel
	var stateData *SegmentResourceModel
	var plan types.Object
	var state types.Object

	// Get the plan data
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get the state data
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert plan to model
	resp.Diagnostics.Append(plan.As(ctx, &planData, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert state to model
	resp.Diagnostics.Append(state.As(ctx, &stateData, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get the segment ID
	tagbasedpolicyID := stateData.ID.ValueString()

	// Start with current state as our base
	data := stateData

	// 1. Check for metadata changes
	// Only consider fields that the user can actually change as part of metadata
	// Ignore computed fields that might be marked as changed in the plan but are actually set by the server
	metadataChanged := false

	// Check if user-settable metadata fields have changed
	if !planData.Description.Equal(stateData.Description) {
		metadataChanged = true
	}

	if !planData.TagBasedPolicyName.Equal(stateData.TagBasedPolicyName) {
		metadataChanged = true
	}

	if !planData.Criteria.Equal(stateData.Criteria) {
		metadataChanged = true
	}

	// Only check these if they're not computed fields
	if !planData.Timeline.IsUnknown() && !stateData.Timeline.IsUnknown() && !planData.Timeline.Equal(stateData.Timeline) {
		metadataChanged = true
	}

	if !planData.TargetBreachImpactScore.IsUnknown() && !stateData.TargetBreachImpactScore.IsUnknown() && !planData.TargetBreachImpactScore.Equal(stateData.TargetBreachImpactScore) {
		metadataChanged = true
	}

	// 2. Check for template changes
	// Create maps for state and plan templates by ID
	stateTemplatesByID := make(map[string]tfTypes.TemplateReference)
	for _, stateTemplate := range stateData.Templates {
		key := stateTemplate.TemplateID.ValueString()
		stateTemplatesByID[key] = stateTemplate
	}

	planTemplatesByID := make(map[string]tfTypes.TemplateReference)
	for _, planTemplate := range planData.Templates {
		key := planTemplate.TemplateID.ValueString()
		planTemplatesByID[key] = planTemplate
	}

	// Find templates to add and remove
	templateIDsToAdd := []string{}
	for key := range planTemplatesByID {
		if _, ok := stateTemplatesByID[key]; !ok {
			templateIDsToAdd = append(templateIDsToAdd, key)
		}
	}

	templateIDsToRemove := []string{}
	for key := range stateTemplatesByID {
		if _, ok := planTemplatesByID[key]; !ok {
			templateIDsToRemove = append(templateIDsToRemove, key)
		}
	}

	// 3. Check for namednetwork changes
	tflog.Info(ctx, "Detecting changes to namednetworks")

	// Create variables for namednetworks to add and remove
	namedNetworkIDsToAdd := []string{}
	namedNetworkIDsToRemove := []string{}

	// Create maps for state and plan namednetworks by ID
	stateNamedNetworksByID := make(map[string]tfTypes.MetadataNamedNetworkReference)
	planNamedNetworksByID := make(map[string]tfTypes.MetadataNamedNetworkReference)

	// Create maps for easier lookup
	planNamedNetworkIDs := make(map[string]bool)
	stateNamedNetworkIDs := make(map[string]bool)

	// Populate the plan maps
	for _, planNamedNetwork := range planData.Namednetworks {
		key := planNamedNetwork.NamedNetworkID.ValueString()
		planNamedNetworksByID[key] = planNamedNetwork
		planNamedNetworkIDs[key] = true
	}

	// Populate the state maps
	for _, stateNamedNetwork := range stateData.Namednetworks {
		key := stateNamedNetwork.NamedNetworkID.ValueString()
		stateNamedNetworksByID[key] = stateNamedNetwork
		stateNamedNetworkIDs[key] = true
	}

	// Find namednetworks to add (in plan but not in state)
	for _, nn := range planData.Namednetworks {
		nnID := nn.NamedNetworkID.ValueString()
		if !stateNamedNetworkIDs[nnID] {
			tflog.Info(ctx, fmt.Sprintf("Adding namednetwork ID %s to the list of IDs to add", nnID))
			namedNetworkIDsToAdd = append(namedNetworkIDsToAdd, nnID)
		}
	}

	// Find namednetworks to remove (in state but not in plan)
	for _, nn := range stateData.Namednetworks {
		nnID := nn.NamedNetworkID.ValueString()
		if !planNamedNetworkIDs[nnID] {
			tflog.Info(ctx, fmt.Sprintf("Adding namednetwork ID %s to the list of IDs to remove", nnID))
			namedNetworkIDsToRemove = append(namedNetworkIDsToRemove, nnID)
		}
	}

	// 1. Handle metadata changes
	if metadataChanged {
		tflog.Info(ctx, fmt.Sprintf("Segment metadata changed: %v", metadataChanged))
		// Update the metadata fields in our data model
		data.Criteria = planData.Criteria
		data.Description = planData.Description
		data.TagBasedPolicyName = planData.TagBasedPolicyName
		data.Timeline = planData.Timeline
		data.TargetBreachImpactScore = planData.TargetBreachImpactScore

		// Create a TagBasedPolicy object with the updated metadata
		description := data.Description.ValueString()
		tagBasedPolicyName := data.TagBasedPolicyName.ValueString()
		criteria := data.Criteria.ValueString()
		targetBreachImpactScore := data.TargetBreachImpactScore.ValueInt64()
		timeline := data.Timeline.ValueInt64()

		tagBasedPolicy := shared.TagBasedPolicy{
			Description:             &description,
			TagBasedPolicyName:      &tagBasedPolicyName,
			Criteria:                &criteria,
			TargetBreachImpactScore: &targetBreachImpactScore,
			Timeline:                &timeline,
		}

		// Create the request for updating metadata
		request := operations.UpdateTagBasedPolicyMetadataRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			TagBasedPolicy:   tagBasedPolicy,
		}
		tflog.Info(ctx, fmt.Sprintf("UpdateTagBasedPolicyMetadata request: TagbasedpolicyID=%s, Description=%s, Name=%s",
			request.TagbasedpolicyID, *request.TagBasedPolicy.Description, *request.TagBasedPolicy.TagBasedPolicyName))

		// Call the API to update metadata
		res, err := r.client.Tagbasedpolicies.UpdateTagBasedPolicyMetadata(ctx, request)

		if err != nil {
			resp.Diagnostics.AddError("failure to update metadata", err.Error())
			if res != nil && res.RawResponse != nil {
				resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
			}
			return
		}

		if res == nil {
			resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
			return
		}

		// The expected response code is 204 (No Content) or 200 (OK)
		if res.StatusCode != 204 && res.StatusCode != 200 {
			resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
			return
		}

		tflog.Info(ctx, "Successfully updated tag-based policy metadata")
	}

	if len(templateIDsToRemove) > 0 {
		// 2. Handle template removals
		// Create the template list
		templateList := shared.TemplateList{
			Templates: templateIDsToRemove,
		}

		// Log the request details
		tflog.Info(ctx, fmt.Sprintf("About to remove templates from segment. TagbasedpolicyID: %s, TemplateIDs: %v", tagbasedpolicyID, templateIDsToRemove))

		// Create the request
		removeTemplatesRequest := operations.TagBasedPolicyBulkTemplateUnApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      templateList,
		}

		// Call the API to remove templates
		tflog.Info(ctx, fmt.Sprintf("Sending TagBasedPolicyBulkTemplateUnApply request for policy ID: %s with %d templates", tagbasedpolicyID, len(templateIDsToRemove)))
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkTemplateUnApply(ctx, removeTemplatesRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			tflog.Info(ctx, fmt.Sprintf("Response from TagBasedPolicyBulkTemplateUnApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL))
		}

		// Handle errors
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for template operation, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkTemplateUnApply: %s", err.Error()))
				resp.Diagnostics.AddError("failure to invoke API", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}
		if res == nil {
			tflog.Error(ctx, "Received nil response from TagBasedPolicyBulkTemplateUnApply")
			resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
			return
		}
		if res.StatusCode != 202 && res.StatusCode != 204 && res.StatusCode != 200 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		tflog.Info(ctx, "Successfully removed templates from segment")
	}

	// 3. Handle template additions
	if len(templateIDsToAdd) > 0 {
		// Create the template list
		templateList := shared.TemplateList{
			Templates: templateIDsToAdd,
		}

		// Log the request details
		tflog.Info(ctx, fmt.Sprintf("About to add templates to segment. TagbasedpolicyID: %s, TemplateIDs: %v", tagbasedpolicyID, templateIDsToAdd))

		// Create the request
		addTemplatesRequest := operations.TagBasedPolicyBulkTemplateApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      templateList,
		}

		// Call the API to add templates
		tflog.Info(ctx, fmt.Sprintf("Sending TagBasedPolicyBulkTemplateApply request for policy ID: %s with %d templates", tagbasedpolicyID, len(templateIDsToAdd)))
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkTemplateApply(ctx, addTemplatesRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			tflog.Info(ctx, fmt.Sprintf("Response from TagBasedPolicyBulkTemplateApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL))
		}

		// Handle errors
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for template operation, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkTemplateApply: %s", err.Error()))
				resp.Diagnostics.AddError("failure to invoke API", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}
		if res == nil {
			tflog.Error(ctx, "Received nil response from TagBasedPolicyBulkTemplateApply")
			resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
			return
		}
		if res.StatusCode != 202 && res.StatusCode != 204 && res.StatusCode != 200 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		tflog.Info(ctx, "Successfully added templates to segment")
	}

	// 4. Handle namednetwork removals

	if len(namedNetworkIDsToRemove) > 0 {
		// Create the namednetwork list
		namedNetworkList := shared.NamedNetworkList{
			Namednetworks: namedNetworkIDsToRemove,
		}

		// Log the request details
		tflog.Info(ctx, fmt.Sprintf("About to remove namednetworks from segment. TagbasedpolicyID: %s, NamedNetworkIDs: %v", tagbasedpolicyID, namedNetworkIDsToRemove))

		// Create the request
		removeNamedNetworksRequest := operations.TagBasedPolicyBulkNamedNetworkUnApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      namedNetworkList,
		}

		tflog.Info(ctx, fmt.Sprintf("Sending TagBasedPolicyBulkNamedNetworkUnApply request for policy ID: %s with %d namednetworks", tagbasedpolicyID, len(namedNetworkIDsToRemove)))
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkNamedNetworkUnApply(ctx, removeNamedNetworksRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			tflog.Info(ctx, fmt.Sprintf("Response from TagBasedPolicyBulkNamedNetworkUnApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL))
		}

		// Handle errors - match the pattern in template_resource.go
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for namednetwork removal, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkNamedNetworkUnApply: %s", err.Error()))
				resp.Diagnostics.AddError("Failed to remove named networks from segment", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}

		// Check for non-success status code (202 Accepted is the expected success code for this API)
		// We also accept 200 OK and 204 No Content as success codes
		if res != nil && res.StatusCode != 202 && res.StatusCode != 204 && res.StatusCode != 200 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code from TagBasedPolicyBulkNamedNetworkUnApply: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		tflog.Info(ctx, "Successfully removed namednetworks from segment")
	}

	// 5. Handle namednetwork additions
	if len(namedNetworkIDsToAdd) > 0 {
		// Create the namednetwork list
		namedNetworkList := shared.NamedNetworkList{
			Namednetworks: namedNetworkIDsToAdd,
		}

		// Log the request details
		logMsg := fmt.Sprintf("About to add namednetworks to segment. TagbasedpolicyID: %s, NamedNetworkIDs: %v", tagbasedpolicyID, namedNetworkIDsToAdd)
		tflog.Info(ctx, logMsg)

		// Create the request
		addNamedNetworksRequest := operations.TagBasedPolicyBulkNamedNetworkApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      namedNetworkList,
		}

		// Call the API to add namednetworks
		logMsg = fmt.Sprintf("Sending TagBasedPolicyBulkNamedNetworkApply request for policy ID: %s with %d namednetworks", tagbasedpolicyID, len(namedNetworkIDsToAdd))
		tflog.Info(ctx, logMsg)

		// Call the API directly, just like in template_resource.go
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkNamedNetworkApply(ctx, addNamedNetworksRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			logMsg = fmt.Sprintf("Response from TagBasedPolicyBulkNamedNetworkApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL)
			tflog.Info(ctx, logMsg)
		}

		// Handle errors - match the pattern in template_resource.go
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for namednetwork apply, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkNamedNetworkApply: %s", err.Error()))
				resp.Diagnostics.AddError("Failed to add named networks to segment", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}
		// Check for non-success status code (202 Accepted is the expected success code for this API)
		// We also accept 200 OK and 204 No Content as success codes
		if res != nil && res.StatusCode != 202 && res.StatusCode != 200 && res.StatusCode != 204 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code from TagBasedPolicyBulkNamedNetworkApply: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		logMsg = "Successfully added namednetworks to segment"
		tflog.Info(ctx, logMsg)
	}

	// 7. If we made any changes, refresh the state from the API
	if metadataChanged || len(templateIDsToAdd) > 0 || len(templateIDsToRemove) > 0 ||
		len(namedNetworkIDsToAdd) > 0 || len(namedNetworkIDsToRemove) > 0 {
		// Read the latest state from the API
		readRequest := operations.GetTagBasedPolicyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
		}
		// Use a wrapper function to catch panics
		readRes, err := func() (*operations.GetTagBasedPolicyResponse, error) {
			defer func() {
				if r := recover(); r != nil {
					tflog.Error(ctx, fmt.Sprintf("PANIC in GetTagBasedPolicy: %v", r))
				}
			}()
			return r.client.Tagbasedpolicies.GetTagBasedPolicy(ctx, readRequest)
		}()
		if err != nil {
			resp.Diagnostics.AddError("Failed to read updated segment", err.Error())
			if readRes != nil && readRes.RawResponse != nil {
				resp.Diagnostics.AddError("unexpected http request/response", debugResponse(readRes.RawResponse))
			}
			return
		}

		// Check for non-success status code
		if readRes != nil && readRes.StatusCode != 200 {
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", readRes.StatusCode),
				debugResponse(readRes.RawResponse),
			)
			return
		}

		// Update our data with the latest from the API
		if readRes.TagBasedPolicyResponse != nil {
			data.RefreshFromSharedTagBasedPolicyResponse(readRes.TagBasedPolicyResponse)
		}
	}

	// Refresh the plan to handle null vs empty conversions for optional computed fields
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SegmentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *SegmentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var tagbasedpolicyID string
	tagbasedpolicyID = data.ID.ValueString()

	request := operations.DeleteTagBasedPolicyRequest{
		TagbasedpolicyID: tagbasedpolicyID,
	}
	res, err := r.client.Tagbasedpolicies.DeleteTagBasedPolicy(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *SegmentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Check if the import ID is a UUID (existing behavior) or a name
	if isSegmentUUID(req.ID) {
		// Existing behavior - direct ID import
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
		return
	}

	// If not a UUID, assume it's a name and look up the segment
	// Create a search criteria that filters by the segment name
	searchCriteria := fmt.Sprintf("tagBasedPolicyName = '%s'", req.ID)
	listReq := operations.ListTagBasedPoliciesRequest{
		SearchInput: shared.SearchInput{
			Criteria: searchCriteria,
		},
	}

	// Add debug logging
	tflog.Info(ctx, "Importing segment by name", map[string]interface{}{
		"name":            req.ID,
		"search_criteria": listReq.SearchInput.Criteria,
	})

	// Try to get the segments
	policies, err := r.client.Tagbasedpolicies.ListTagBasedPolicies(ctx, listReq)

	if err != nil {
		resp.Diagnostics.AddError(
			"Error retrieving segments",
			fmt.Sprintf("Could not list segments to find by name: %s", err),
		)
		return
	}

	// Process the JSON response
	if policies.TagBasedPolicies != nil && len(policies.TagBasedPolicies.Items) > 0 {
		// Find the segment with the matching name
		var foundID string
		for _, policy := range policies.TagBasedPolicies.Items {
			if policy.TagBasedPolicyName != nil && *policy.TagBasedPolicyName == req.ID {
				if policy.TagBasedPolicyID != nil {
					foundID = *policy.TagBasedPolicyID
					break
				}
			}
		}

		if foundID != "" {
			tflog.Info(ctx, "Found segment", map[string]interface{}{
				"id":   foundID,
				"name": req.ID,
			})
			resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), foundID)...)
			return
		}
	}

	resp.Diagnostics.AddError(
		"Segment not found",
		fmt.Sprintf("No segment found with name: %s", req.ID),
	)
}

// Helper to check if a string is a UUID
func isSegmentUUID(s string) bool {
	// Simple UUID format check (not comprehensive)
	matched, _ := regexp.MatchString(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, strings.ToLower(s))
	return matched
}
