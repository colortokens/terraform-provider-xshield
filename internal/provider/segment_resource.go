// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-log/tflog"

	tfTypes "github.com/colortokens/terraform-provider-xshield/internal/provider/types"
	"github.com/colortokens/terraform-provider-xshield/internal/sdk"
	"github.com/colortokens/terraform-provider-xshield/internal/sdk/models/operations"
	"github.com/colortokens/terraform-provider-xshield/internal/sdk/models/shared"
	speakeasy_objectvalidators "github.com/colortokens/terraform-provider-xshield/internal/validators/objectvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &SegmentResource{}
var _ resource.ResourceWithImportState = &SegmentResource{}

func NewSegmentResource() resource.Resource {
	return &SegmentResource{}
}

// SegmentResource defines the resource implementation.
type SegmentResource struct {
	client *sdk.Xshield
}

// SegmentResourceModel describes the resource data model.
type SegmentResourceModel struct {
	AutoSynchronizeEnabled               types.Bool                              `tfsdk:"auto_synchronize_enabled"`
	BaselineBreachImpactScore            types.Int64                             `tfsdk:"baseline_breach_impact_score"`
	BaselineMatchingAssets               types.Int64                             `tfsdk:"baseline_matching_assets"`
	Criteria                             types.String                            `tfsdk:"criteria"`
	Description                          types.String                            `tfsdk:"description"`
	ID                                   types.String                            `tfsdk:"id"`
	LowestInboundPolicyStatus            types.String                            `tfsdk:"lowest_inbound_policy_status"`
	LowestOutboundPolicyStatus           types.String                            `tfsdk:"lowest_outbound_policy_status"`
	LowestProgressiveInboundPolicyStatus types.String                            `tfsdk:"lowest_progressive_inbound_policy_status"`
	MatchingAssets                       types.Int64                             `tfsdk:"matching_assets"`
	Milestones                           []tfTypes.TagBasedPolicyMilestone       `tfsdk:"milestones"`
	Namednetworks                        []tfTypes.MetadataNamedNetworkReference `tfsdk:"namednetworks"`
	PolicyAutomationConfigurable         types.Bool                              `tfsdk:"policy_automation_configurable"`
	TagBasedPolicyName                   types.String                            `tfsdk:"tag_based_policy_name"`
	TargetBreachImpactScore              types.Int64                             `tfsdk:"target_breach_impact_score"`
	Templates                            []tfTypes.TemplateReference             `tfsdk:"templates"`
	Timeline                             types.Int64                             `tfsdk:"timeline"`
}

func (r *SegmentResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_segment"
}

func (r *SegmentResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Segment Resource",
		Attributes: map[string]schema.Attribute{
			"auto_synchronize_enabled": schema.BoolAttribute{
				Computed: true,
			},
			"baseline_breach_impact_score": schema.Int64Attribute{
				Computed: true,
			},
			"baseline_matching_assets": schema.Int64Attribute{
				Computed: true,
			},
			"criteria": schema.StringAttribute{
				Computed: true,
				Optional: true,
				// Note: The API might modify the criteria by adding additional conditions
				// For example, it might add "AND 'managedby' in ('colortokens')" to the criteria
			},
			"description": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(1000),
				},
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"lowest_inbound_policy_status": schema.StringAttribute{
				Computed: true,
			},
			"lowest_outbound_policy_status": schema.StringAttribute{
				Computed: true,
			},
			"lowest_progressive_inbound_policy_status": schema.StringAttribute{
				Computed: true,
			},
			"matching_assets": schema.Int64Attribute{
				Computed: true,
			},
			"milestones": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"completion_percentage": schema.NumberAttribute{
							Computed: true,
						},
						"milestone_id": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"namednetworks": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"named_network_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
						"named_network_name": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
					},
				},
			},
			"policy_automation_configurable": schema.BoolAttribute{
				Computed: true,
			},
			"tag_based_policy_name": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(256),
				},
			},
			"target_breach_impact_score": schema.Int64Attribute{
				Computed: true,
				Optional: true,
				Validators: []validator.Int64{
					int64validator.AtMost(100),
				},
			},
			"templates": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"template_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
						"template_name": schema.StringAttribute{
							Computed: true,
							Optional: true,
						},
					},
				},
			},
			"timeline": schema.Int64Attribute{
				Computed: true,
				Optional: true,
				Validators: []validator.Int64{
					int64validator.AtLeast(1),
				},
			},
		},
	}
}

func (r *SegmentResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Xshield)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Xshield, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SegmentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *SegmentResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedTagBasedPolicy()
	res, err := r.client.Tagbasedpolicies.CreateTagBasedPolicy(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 202 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.TagBasedPolicyResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedTagBasedPolicyResponse(res.TagBasedPolicyResponse)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SegmentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *SegmentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save the current values of fields we want to preserve
	targetBreachImpactScore := data.TargetBreachImpactScore
	timeline := data.Timeline
	criteria := data.Criteria

	var tagbasedpolicyID string
	tagbasedpolicyID = data.ID.ValueString()

	request := operations.GetTagBasedPolicyRequest{
		TagbasedpolicyID: tagbasedpolicyID,
	}
	res, err := r.client.Tagbasedpolicies.GetTagBasedPolicy(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.TagBasedPolicyResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedTagBasedPolicyResponse(res.TagBasedPolicyResponse)

	// Set computed fields to null
	data.AutoSynchronizeEnabled = types.BoolNull()
	data.BaselineBreachImpactScore = types.Int64Null()
	data.BaselineMatchingAssets = types.Int64Null()
	data.LowestInboundPolicyStatus = types.StringNull()
	data.LowestOutboundPolicyStatus = types.StringNull()
	data.LowestProgressiveInboundPolicyStatus = types.StringNull()
	data.MatchingAssets = types.Int64Null()
	data.Milestones = []tfTypes.TagBasedPolicyMilestone{}
	data.PolicyAutomationConfigurable = types.BoolNull()

	// Restore preserved fields
	data.TargetBreachImpactScore = targetBreachImpactScore
	data.Timeline = timeline
	data.Criteria = criteria

	// Only set namednetwork_name to null if it's not returned by the API
	for i := range data.Namednetworks {
		if data.Namednetworks[i].NamedNetworkName.IsNull() || data.Namednetworks[i].NamedNetworkName.ValueString() == "" {
			data.Namednetworks[i].NamedNetworkName = types.StringNull()
		}
	}

	// Only set template_name to null if it's not returned by the API
	for i := range data.Templates {
		if data.Templates[i].TemplateName.IsNull() || data.Templates[i].TemplateName.ValueString() == "" {
			data.Templates[i].TemplateName = types.StringNull()
		}
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SegmentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var planData *SegmentResourceModel
	var stateData *SegmentResourceModel
	var plan types.Object
	var state types.Object

	// Get the plan data
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get the state data
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert plan to model
	resp.Diagnostics.Append(plan.As(ctx, &planData, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert state to model
	resp.Diagnostics.Append(state.As(ctx, &stateData, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get the segment ID
	tagbasedpolicyID := stateData.ID.ValueString()

	// Start with current state as our base
	data := stateData

	// 1. Check for metadata changes
	// Only consider fields that the user can actually change as part of metadata
	// Ignore computed fields that might be marked as changed in the plan but are actually set by the server
	metadataChanged := false

	// Check if user-settable metadata fields have changed
	if !planData.Description.Equal(stateData.Description) {
		metadataChanged = true
	}

	if !planData.TagBasedPolicyName.Equal(stateData.TagBasedPolicyName) {
		metadataChanged = true
	}

	if !planData.Criteria.Equal(stateData.Criteria) {
		metadataChanged = true
	}

	// Only check these if they're not computed fields
	if !planData.Timeline.IsUnknown() && !stateData.Timeline.IsUnknown() && !planData.Timeline.Equal(stateData.Timeline) {
		metadataChanged = true
	}

	if !planData.TargetBreachImpactScore.IsUnknown() && !stateData.TargetBreachImpactScore.IsUnknown() && !planData.TargetBreachImpactScore.Equal(stateData.TargetBreachImpactScore) {
		metadataChanged = true
	}

	// 2. Check for template changes
	// Create maps for state and plan templates by ID
	stateTemplatesByID := make(map[string]tfTypes.TemplateReference)
	for _, stateTemplate := range stateData.Templates {
		key := stateTemplate.TemplateID.ValueString()
		stateTemplatesByID[key] = stateTemplate
	}

	planTemplatesByID := make(map[string]tfTypes.TemplateReference)
	for _, planTemplate := range planData.Templates {
		key := planTemplate.TemplateID.ValueString()
		planTemplatesByID[key] = planTemplate
	}

	// Find templates to add and remove
	templateIDsToAdd := []string{}
	for key := range planTemplatesByID {
		if _, ok := stateTemplatesByID[key]; !ok {
			templateIDsToAdd = append(templateIDsToAdd, key)
		}
	}

	templateIDsToRemove := []string{}
	for key := range stateTemplatesByID {
		if _, ok := planTemplatesByID[key]; !ok {
			templateIDsToRemove = append(templateIDsToRemove, key)
		}
	}

	// 3. Check for namednetwork changes
	tflog.Info(ctx, "Detecting changes to namednetworks")

	// Create variables for namednetworks to add and remove
	namedNetworkIDsToAdd := []string{}
	namedNetworkIDsToRemove := []string{}

	// Create maps for state and plan namednetworks by ID
	stateNamedNetworksByID := make(map[string]tfTypes.MetadataNamedNetworkReference)
	planNamedNetworksByID := make(map[string]tfTypes.MetadataNamedNetworkReference)

	// Create maps for easier lookup
	planNamedNetworkIDs := make(map[string]bool)
	stateNamedNetworkIDs := make(map[string]bool)

	// Populate the plan maps
	for _, planNamedNetwork := range planData.Namednetworks {
		key := planNamedNetwork.NamedNetworkID.ValueString()
		planNamedNetworksByID[key] = planNamedNetwork
		planNamedNetworkIDs[key] = true
	}

	// Populate the state maps
	for _, stateNamedNetwork := range stateData.Namednetworks {
		key := stateNamedNetwork.NamedNetworkID.ValueString()
		stateNamedNetworksByID[key] = stateNamedNetwork
		stateNamedNetworkIDs[key] = true
	}

	// Find namednetworks to add (in plan but not in state)
	for _, nn := range planData.Namednetworks {
		nnID := nn.NamedNetworkID.ValueString()
		if !stateNamedNetworkIDs[nnID] {
			tflog.Info(ctx, fmt.Sprintf("Adding namednetwork ID %s to the list of IDs to add", nnID))
			namedNetworkIDsToAdd = append(namedNetworkIDsToAdd, nnID)
		}
	}

	// Find namednetworks to remove (in state but not in plan)
	for _, nn := range stateData.Namednetworks {
		nnID := nn.NamedNetworkID.ValueString()
		if !planNamedNetworkIDs[nnID] {
			tflog.Info(ctx, fmt.Sprintf("Adding namednetwork ID %s to the list of IDs to remove", nnID))
			namedNetworkIDsToRemove = append(namedNetworkIDsToRemove, nnID)
		}
	}

	// 1. Handle metadata changes
	if metadataChanged {
		tflog.Info(ctx, fmt.Sprintf("Segment metadata changed: %v", metadataChanged))
		// Update the metadata fields in our data model
		data.Criteria = planData.Criteria
		data.Description = planData.Description
		data.TagBasedPolicyName = planData.TagBasedPolicyName
		data.Timeline = planData.Timeline
		data.TargetBreachImpactScore = planData.TargetBreachImpactScore

		// Create a TagBasedPolicy object with the updated metadata
		description := data.Description.ValueString()
		tagBasedPolicyName := data.TagBasedPolicyName.ValueString()
		criteria := data.Criteria.ValueString()
		targetBreachImpactScore := data.TargetBreachImpactScore.ValueInt64()
		timeline := data.Timeline.ValueInt64()

		tagBasedPolicy := shared.TagBasedPolicy{
			Description:             &description,
			TagBasedPolicyName:      &tagBasedPolicyName,
			Criteria:                &criteria,
			TargetBreachImpactScore: &targetBreachImpactScore,
			Timeline:                &timeline,
		}

		// Create the request for updating metadata
		request := operations.UpdateTagBasedPolicyMetadataRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			TagBasedPolicy:   tagBasedPolicy,
		}
		tflog.Info(ctx, fmt.Sprintf("UpdateTagBasedPolicyMetadata request: TagbasedpolicyID=%s, Description=%s, Name=%s",
			request.TagbasedpolicyID, *request.TagBasedPolicy.Description, *request.TagBasedPolicy.TagBasedPolicyName))

		// Call the API to update metadata
		res, err := r.client.Tagbasedpolicies.UpdateTagBasedPolicyMetadata(ctx, request)

		if err != nil {
			resp.Diagnostics.AddError("failure to update metadata", err.Error())
			if res != nil && res.RawResponse != nil {
				resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
			}
			return
		}

		if res == nil {
			resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
			return
		}

		// The expected response code is 204 (No Content) or 200 (OK)
		if res.StatusCode != 204 && res.StatusCode != 200 {
			resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
			return
		}

		tflog.Info(ctx, "Successfully updated tag-based policy metadata")
	}

	if len(templateIDsToRemove) > 0 {
		// 2. Handle template removals
		// Create the template list
		templateList := shared.TemplateList{
			Templates: templateIDsToRemove,
		}

		// Log the request details
		tflog.Info(ctx, fmt.Sprintf("About to remove templates from segment. TagbasedpolicyID: %s, TemplateIDs: %v", tagbasedpolicyID, templateIDsToRemove))

		// Create the request
		removeTemplatesRequest := operations.TagBasedPolicyBulkTemplateUnApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      templateList,
		}

		// Call the API to remove templates
		tflog.Info(ctx, fmt.Sprintf("Sending TagBasedPolicyBulkTemplateUnApply request for policy ID: %s with %d templates", tagbasedpolicyID, len(templateIDsToRemove)))
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkTemplateUnApply(ctx, removeTemplatesRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			tflog.Info(ctx, fmt.Sprintf("Response from TagBasedPolicyBulkTemplateUnApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL))
		}

		// Handle errors
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for template operation, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkTemplateUnApply: %s", err.Error()))
				resp.Diagnostics.AddError("failure to invoke API", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}
		if res == nil {
			tflog.Error(ctx, "Received nil response from TagBasedPolicyBulkTemplateUnApply")
			resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
			return
		}
		if res.StatusCode != 202 && res.StatusCode != 204 && res.StatusCode != 200 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		tflog.Info(ctx, "Successfully removed templates from segment")
	}

	// 3. Handle template additions
	if len(templateIDsToAdd) > 0 {
		// Create the template list
		templateList := shared.TemplateList{
			Templates: templateIDsToAdd,
		}

		// Log the request details
		tflog.Info(ctx, fmt.Sprintf("About to add templates to segment. TagbasedpolicyID: %s, TemplateIDs: %v", tagbasedpolicyID, templateIDsToAdd))

		// Create the request
		addTemplatesRequest := operations.TagBasedPolicyBulkTemplateApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      templateList,
		}

		// Call the API to add templates
		tflog.Info(ctx, fmt.Sprintf("Sending TagBasedPolicyBulkTemplateApply request for policy ID: %s with %d templates", tagbasedpolicyID, len(templateIDsToAdd)))
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkTemplateApply(ctx, addTemplatesRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			tflog.Info(ctx, fmt.Sprintf("Response from TagBasedPolicyBulkTemplateApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL))
		}

		// Handle errors
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for template operation, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkTemplateApply: %s", err.Error()))
				resp.Diagnostics.AddError("failure to invoke API", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}
		if res == nil {
			tflog.Error(ctx, "Received nil response from TagBasedPolicyBulkTemplateApply")
			resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
			return
		}
		if res.StatusCode != 202 && res.StatusCode != 204 && res.StatusCode != 200 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		tflog.Info(ctx, "Successfully added templates to segment")
	}

	// 4. Handle namednetwork removals

	if len(namedNetworkIDsToRemove) > 0 {
		// Create the namednetwork list
		namedNetworkList := shared.NamedNetworkList{
			Namednetworks: namedNetworkIDsToRemove,
		}

		// Log the request details
		tflog.Info(ctx, fmt.Sprintf("About to remove namednetworks from segment. TagbasedpolicyID: %s, NamedNetworkIDs: %v", tagbasedpolicyID, namedNetworkIDsToRemove))

		// Create the request
		removeNamedNetworksRequest := operations.TagBasedPolicyBulkNamedNetworkUnApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      namedNetworkList,
		}

		tflog.Info(ctx, fmt.Sprintf("Sending TagBasedPolicyBulkNamedNetworkUnApply request for policy ID: %s with %d namednetworks", tagbasedpolicyID, len(namedNetworkIDsToRemove)))
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkNamedNetworkUnApply(ctx, removeNamedNetworksRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			tflog.Info(ctx, fmt.Sprintf("Response from TagBasedPolicyBulkNamedNetworkUnApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL))
		}

		// Handle errors - match the pattern in template_resource.go
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for namednetwork removal, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkNamedNetworkUnApply: %s", err.Error()))
				resp.Diagnostics.AddError("Failed to remove named networks from segment", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}

		// Check for non-success status code (202 Accepted is the expected success code for this API)
		// We also accept 200 OK and 204 No Content as success codes
		if res != nil && res.StatusCode != 202 && res.StatusCode != 204 && res.StatusCode != 200 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code from TagBasedPolicyBulkNamedNetworkUnApply: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		tflog.Info(ctx, "Successfully removed namednetworks from segment")
	}

	// 5. Handle namednetwork additions
	if len(namedNetworkIDsToAdd) > 0 {
		// Create the namednetwork list
		namedNetworkList := shared.NamedNetworkList{
			Namednetworks: namedNetworkIDsToAdd,
		}

		// Log the request details
		logMsg := fmt.Sprintf("About to add namednetworks to segment. TagbasedpolicyID: %s, NamedNetworkIDs: %v", tagbasedpolicyID, namedNetworkIDsToAdd)
		tflog.Info(ctx, logMsg)

		// Create the request
		addNamedNetworksRequest := operations.TagBasedPolicyBulkNamedNetworkApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      namedNetworkList,
		}

		// Call the API to add namednetworks
		logMsg = fmt.Sprintf("Sending TagBasedPolicyBulkNamedNetworkApply request for policy ID: %s with %d namednetworks", tagbasedpolicyID, len(namedNetworkIDsToAdd))
		tflog.Info(ctx, logMsg)

		// Call the API directly, just like in template_resource.go
		res, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkNamedNetworkApply(ctx, addNamedNetworksRequest)

		// Log the response
		if res != nil && res.RawResponse != nil {
			logMsg = fmt.Sprintf("Response from TagBasedPolicyBulkNamedNetworkApply: Status: %d, URL: %s", res.StatusCode, res.RawResponse.Request.URL)
			tflog.Info(ctx, logMsg)
		}

		// Handle errors - match the pattern in template_resource.go
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if res != nil && res.StatusCode == 202 {
				tflog.Info(ctx, fmt.Sprintf("Received 202 status code for namednetwork apply, which is a success despite the error: %s", err.Error()))
				// This is actually a success, so we'll continue
			} else {
				tflog.Error(ctx, fmt.Sprintf("Error from TagBasedPolicyBulkNamedNetworkApply: %s", err.Error()))
				resp.Diagnostics.AddError("Failed to add named networks to segment", err.Error())
				if res != nil && res.RawResponse != nil {
					tflog.Error(ctx, fmt.Sprintf("Response details: %s", debugResponse(res.RawResponse)))
					resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
				}
				return
			}
		}
		// Check for non-success status code (202 Accepted is the expected success code for this API)
		// We also accept 200 OK and 204 No Content as success codes
		if res != nil && res.StatusCode != 202 && res.StatusCode != 200 && res.StatusCode != 204 {
			tflog.Error(ctx, fmt.Sprintf("Unexpected status code from TagBasedPolicyBulkNamedNetworkApply: %d", res.StatusCode))
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode),
				debugResponse(res.RawResponse),
			)
			return
		}

		logMsg = "Successfully added namednetworks to segment"
		tflog.Info(ctx, logMsg)
	}

	// 7. If we made any changes, refresh the state from the API
	if metadataChanged || len(templateIDsToAdd) > 0 || len(templateIDsToRemove) > 0 ||
		len(namedNetworkIDsToAdd) > 0 || len(namedNetworkIDsToRemove) > 0 {
		// Read the latest state from the API
		readRequest := operations.GetTagBasedPolicyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
		}
		// Use a wrapper function to catch panics
		readRes, err := func() (*operations.GetTagBasedPolicyResponse, error) {
			defer func() {
				if r := recover(); r != nil {
					tflog.Error(ctx, fmt.Sprintf("PANIC in GetTagBasedPolicy: %v", r))
				}
			}()
			return r.client.Tagbasedpolicies.GetTagBasedPolicy(ctx, readRequest)
		}()
		if err != nil {
			resp.Diagnostics.AddError("Failed to read updated segment", err.Error())
			if readRes != nil && readRes.RawResponse != nil {
				resp.Diagnostics.AddError("unexpected http request/response", debugResponse(readRes.RawResponse))
			}
			return
		}

		// Check for non-success status code
		if readRes != nil && readRes.StatusCode != 200 {
			resp.Diagnostics.AddError(
				fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", readRes.StatusCode),
				debugResponse(readRes.RawResponse),
			)
			return
		}

		// Update our data with the latest from the API
		if readRes.TagBasedPolicyResponse != nil {
			data.RefreshFromSharedTagBasedPolicyResponse(readRes.TagBasedPolicyResponse)
		}
	}

	// Refresh the plan to handle null vs empty conversions for optional computed fields
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SegmentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *SegmentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var tagbasedpolicyID string
	tagbasedpolicyID = data.ID.ValueString()
	tflog.Info(ctx, "Deleting segment", map[string]interface{}{
		"segment_id":   tagbasedpolicyID,
		"segment_name": data.TagBasedPolicyName.ValueString(),
	})

	// First, get the current segment to check if it has named networks or templates
	tflog.Info(ctx, "Getting segment details before deletion", map[string]interface{}{
		"segment_id": tagbasedpolicyID,
		"step":       "pre_delete_get",
	})

	getRequest := operations.GetTagBasedPolicyRequest{
		TagbasedpolicyID: tagbasedpolicyID,
	}
	getRes, err := r.client.Tagbasedpolicies.GetTagBasedPolicy(ctx, getRequest)
	if err != nil {
		tflog.Error(ctx, "Failed to get segment before deletion", map[string]interface{}{
			"segment_id": tagbasedpolicyID,
			"error":      err.Error(),
			"step":       "pre_delete_get",
		})
		resp.Diagnostics.AddError("failure to get segment before deletion", err.Error())
		if getRes != nil && getRes.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(getRes.RawResponse))
		}
		return
	}

	var namedNetworkCount, templateCount int
	if getRes.TagBasedPolicyResponse != nil {
		namedNetworkCount = len(getRes.TagBasedPolicyResponse.Namednetworks)
		templateCount = len(getRes.TagBasedPolicyResponse.Templates)
	}

	tflog.Info(ctx, "Successfully retrieved segment details", map[string]interface{}{
		"segment_id":          tagbasedpolicyID,
		"has_named_networks":  getRes.TagBasedPolicyResponse != nil && namedNetworkCount > 0,
		"named_network_count": namedNetworkCount,
		"has_templates":       getRes.TagBasedPolicyResponse != nil && templateCount > 0,
		"template_count":      templateCount,
		"step":                "pre_delete_get",
	})

	// If the segment has named networks, detach them
	if getRes.TagBasedPolicyResponse != nil && len(getRes.TagBasedPolicyResponse.Namednetworks) > 0 {
		tflog.Info(ctx, "Detaching named networks before segment deletion", map[string]interface{}{
			"segment_id":          tagbasedpolicyID,
			"named_network_count": len(getRes.TagBasedPolicyResponse.Namednetworks),
		})

		// Extract named network IDs
		namedNetworkIDs := []string{}
		namedNetworkNames := []string{}
		for _, nn := range getRes.TagBasedPolicyResponse.Namednetworks {
			if nn.NamedNetworkID != nil {
				namedNetworkIDs = append(namedNetworkIDs, *nn.NamedNetworkID)
				if nn.NamedNetworkName != nil {
					namedNetworkNames = append(namedNetworkNames, *nn.NamedNetworkName)
				} else {
					namedNetworkNames = append(namedNetworkNames, "<unnamed>")
				}
			}
		}

		tflog.Info(ctx, "Named networks to detach", map[string]interface{}{
			"segment_id":          tagbasedpolicyID,
			"named_network_ids":   namedNetworkIDs,
			"named_network_names": namedNetworkNames,
			"count":               len(namedNetworkIDs),
			"step":                "named_network_detach_prepare",
		})

		// Create the namednetwork list for bulk unapply
		namedNetworkList := shared.NamedNetworkList{
			Namednetworks: namedNetworkIDs,
		}

		// Create the request for bulk named network unapply
		removeNamedNetworksRequest := operations.TagBasedPolicyBulkNamedNetworkUnApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      namedNetworkList,
		}

		// Call the API to remove named networks
		tflog.Info(ctx, "Sending request to detach named networks", map[string]interface{}{
			"segment_id":          tagbasedpolicyID,
			"named_network_count": len(namedNetworkIDs),
			"api_method":          "TagBasedPolicyBulkNamedNetworkUnApply",
			"step":                "named_network_detach_request",
		})

		nnRes, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkNamedNetworkUnApply(ctx, removeNamedNetworksRequest)

		// Handle errors
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if nnRes != nil && nnRes.StatusCode == 202 {
				tflog.Info(ctx, "Named network detachment succeeded with 202 status", map[string]interface{}{
					"segment_id":    tagbasedpolicyID,
					"status_code":   202,
					"error_message": err.Error(),
					"step":          "named_network_detach_response",
				})
				// This is actually a success, so we'll continue
			} else {
				var statusCode int
				if nnRes != nil {
					statusCode = nnRes.StatusCode
				} else {
					statusCode = -1
				}
				tflog.Error(ctx, "Failed to detach named networks", map[string]interface{}{
					"segment_id":  tagbasedpolicyID,
					"error":       err.Error(),
					"status_code": statusCode,
					"step":        "named_network_detach_error",
				})
				resp.Diagnostics.AddError("failure to detach named networks", err.Error())
				if nnRes != nil && nnRes.RawResponse != nil {
					responseDetails := debugResponse(nnRes.RawResponse)
					tflog.Error(ctx, "Response details from failed named network detachment", map[string]interface{}{
						"segment_id":       tagbasedpolicyID,
						"response_details": responseDetails,
						"step":             "named_network_detach_error_details",
					})
					resp.Diagnostics.AddError("unexpected http request/response", responseDetails)
				}
				return
			}
		} else {
			var statusCode int
			if nnRes != nil {
				statusCode = nnRes.StatusCode
			} else {
				statusCode = -1
			}
			tflog.Info(ctx, "Successfully detached named networks", map[string]interface{}{
				"segment_id":  tagbasedpolicyID,
				"status_code": statusCode,
				"step":        "named_network_detach_success",
			})
		}
	}

	// If the segment has templates, detach them
	if getRes.TagBasedPolicyResponse != nil && len(getRes.TagBasedPolicyResponse.Templates) > 0 {
		tflog.Info(ctx, "Detaching templates before segment deletion", map[string]interface{}{
			"segment_id":     tagbasedpolicyID,
			"template_count": len(getRes.TagBasedPolicyResponse.Templates),
		})

		// Extract template IDs
		templateIDs := []string{}
		templateNames := []string{}
		for _, template := range getRes.TagBasedPolicyResponse.Templates {
			if template.TemplateID != nil {
				templateIDs = append(templateIDs, *template.TemplateID)
				if template.TemplateName != nil {
					templateNames = append(templateNames, *template.TemplateName)
				} else {
					templateNames = append(templateNames, "<unnamed>")
				}
			}
		}

		tflog.Info(ctx, "Templates to detach", map[string]interface{}{
			"segment_id":     tagbasedpolicyID,
			"template_ids":   templateIDs,
			"template_names": templateNames,
			"count":          len(templateIDs),
			"step":           "template_detach_prepare",
		})

		// Create the template list for bulk unapply
		templateList := shared.TemplateList{
			Templates: templateIDs,
		}

		// Create the request for bulk template unapply
		removeTemplatesRequest := operations.TagBasedPolicyBulkTemplateUnApplyRequest{
			TagbasedpolicyID: tagbasedpolicyID,
			RequestBody:      templateList,
		}

		// Call the API to remove templates
		tflog.Info(ctx, "Sending request to detach templates", map[string]interface{}{
			"segment_id":     tagbasedpolicyID,
			"template_count": len(templateIDs),
			"api_method":     "TagBasedPolicyBulkTemplateUnApply",
			"step":           "template_detach_request",
		})

		templateRes, err := r.client.Tagbasedpolicies.TagBasedPolicyBulkTemplateUnApply(ctx, removeTemplatesRequest)

		// Handle errors
		if err != nil {
			// Check if the error is due to a 202 status code, which is actually a success
			if templateRes != nil && templateRes.StatusCode == 202 {
				tflog.Info(ctx, "Template detachment succeeded with 202 status", map[string]interface{}{
					"segment_id":    tagbasedpolicyID,
					"status_code":   202,
					"error_message": err.Error(),
					"step":          "template_detach_response",
				})
				// This is actually a success, so we'll continue
			} else {
				var statusCode int
				if templateRes != nil {
					statusCode = templateRes.StatusCode
				} else {
					statusCode = -1
				}
				tflog.Error(ctx, "Failed to detach templates", map[string]interface{}{
					"segment_id":  tagbasedpolicyID,
					"error":       err.Error(),
					"status_code": statusCode,
					"step":        "template_detach_error",
				})
				resp.Diagnostics.AddError("failure to detach templates", err.Error())
				if templateRes != nil && templateRes.RawResponse != nil {
					responseDetails := debugResponse(templateRes.RawResponse)
					tflog.Error(ctx, "Response details from failed template detachment", map[string]interface{}{
						"segment_id":       tagbasedpolicyID,
						"response_details": responseDetails,
						"step":             "template_detach_error_details",
					})
					resp.Diagnostics.AddError("unexpected http request/response", responseDetails)
				}
				return
			}
		} else {
			var statusCode int
			if templateRes != nil {
				statusCode = templateRes.StatusCode
			} else {
				statusCode = -1
			}
			tflog.Info(ctx, "Successfully detached templates", map[string]interface{}{
				"segment_id":  tagbasedpolicyID,
				"status_code": statusCode,
				"step":        "template_detach_success",
			})
		}
	}

	// Proceed with deletion
	request := operations.DeleteTagBasedPolicyRequest{
		TagbasedpolicyID: tagbasedpolicyID,
	}
	tflog.Info(ctx, "Sending DeleteTagBasedPolicy request", map[string]interface{}{
		"segment_id": tagbasedpolicyID,
		"api_method": "DeleteTagBasedPolicy",
		"step":       "segment_delete_request",
	})

	res, err := r.client.Tagbasedpolicies.DeleteTagBasedPolicy(ctx, request)

	if err != nil {
		tflog.Error(ctx, "Error deleting segment", map[string]interface{}{
			"segment_id": tagbasedpolicyID,
			"error":      err.Error(),
			"step":       "segment_delete_error",
		})

		// Check for 404 errors in different ways
		if res != nil && res.StatusCode == 404 {
			tflog.Info(ctx, "Segment already deleted (404 status code)", map[string]interface{}{
				"segment_id": tagbasedpolicyID,
				"step":       "segment_delete_404",
			})
			return
		}

		// Also check for 404 in the error message
		if strings.Contains(err.Error(), "Status 404") {
			tflog.Info(ctx, "Segment already deleted (404 in error message)", map[string]interface{}{
				"segment_id": tagbasedpolicyID,
				"error":      err.Error(),
				"step":       "segment_delete_404_message",
			})
			return
		}

		// Check for 409 conflict in the error message
		if strings.Contains(err.Error(), "Status 409") {
			tflog.Info(ctx, "Segment deletion returned 409 conflict - background process still running, will retry with backoff", map[string]interface{}{
				"segment_id": tagbasedpolicyID,
				"error":      err.Error(),
				"step":       "segment_delete_conflict",
			})

			// Retry with exponential backoff: 5s, 8s, 11s
			maxRetries := 10
			baseDelay := 5
			increment := 3

			for attempt := 1; attempt <= maxRetries; attempt++ {
				// Calculate delay: 5 + (attempt-1)*3 seconds
				currentDelay := baseDelay + (attempt-1)*increment

				tflog.Info(ctx, "Waiting before retry attempt", map[string]interface{}{
					"segment_id": tagbasedpolicyID,
					"attempt":    attempt,
					"delay_sec":  currentDelay,
					"step":       "segment_delete_backoff",
				})
				time.Sleep(time.Duration(currentDelay) * time.Second)

				// Try deletion
				tflog.Info(ctx, "Retrying segment deletion", map[string]interface{}{
					"segment_id":  tagbasedpolicyID,
					"attempt":     attempt,
					"max_retries": maxRetries,
					"step":        "segment_delete_retry",
				})
				retryRes, retryErr := r.client.Tagbasedpolicies.DeleteTagBasedPolicy(ctx, request)

				// Success
				if retryErr == nil && (retryRes.StatusCode == 200 || retryRes.StatusCode == 202 || retryRes.StatusCode == 404) {
					tflog.Info(ctx, "Segment deletion successful on retry", map[string]interface{}{
						"segment_id":  tagbasedpolicyID,
						"status_code": retryRes.StatusCode,
						"attempt":     attempt,
						"step":        "segment_delete_success",
					})
					return
				}

				// Handle 404 in error
				if retryErr != nil && strings.Contains(retryErr.Error(), "Status 404") {
					tflog.Info(ctx, "Segment already deleted on retry", map[string]interface{}{
						"segment_id": tagbasedpolicyID,
						"attempt":    attempt,
						"step":       "segment_delete_404",
					})
					return
				}

				// If still 409 and this is the last attempt, treat as success
				if retryErr != nil && strings.Contains(retryErr.Error(), "Status 409") && attempt == maxRetries {
					tflog.Info(ctx, "Segment deletion still getting 409 after max retries - treating as success", map[string]interface{}{
						"segment_id": tagbasedpolicyID,
						"attempt":    attempt,
						"step":       "segment_delete_max_retries",
					})
					return
				}

				// Log error but continue to next retry if not last attempt
				if retryErr != nil {
					tflog.Warn(ctx, "Retry attempt failed, will continue", map[string]interface{}{
						"segment_id": tagbasedpolicyID,
						"error":      retryErr.Error(),
						"attempt":    attempt,
						"step":       "segment_delete_retry_failed",
					})
				}
			}

			// If we get here, all retries failed
			tflog.Error(ctx, "Failed to delete segment after all retries", map[string]interface{}{
				"segment_id":  tagbasedpolicyID,
				"max_retries": maxRetries,
				"step":        "segment_delete_all_retries_failed",
			})
			resp.Diagnostics.AddError("failure to delete segment after retries", "Segment deletion failed after multiple retry attempts")
			return
		}

		// If we get here, it's a real error
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			responseDetails := debugResponse(res.RawResponse)
			tflog.Error(ctx, "Response details from failed segment deletion", map[string]interface{}{
				"segment_id":       tagbasedpolicyID,
				"response_details": responseDetails,
				"status_code":      res.StatusCode,
				"step":             "segment_delete_error_details",
			})
			resp.Diagnostics.AddError("unexpected http request/response", responseDetails)
		}
		return
	}

	// If we get here, there was no error, but we should still check for valid status codes
	if res == nil {
		tflog.Error(ctx, "Received nil response from DeleteTagBasedPolicy", map[string]interface{}{
			"segment_id": tagbasedpolicyID,
		})
		resp.Diagnostics.AddError("unexpected nil response from API", "DeleteTagBasedPolicy returned nil response")
		return
	}

	// Verify we have a success status code (200, 202, or 404)
	if res.StatusCode != 200 && res.StatusCode != 202 && res.StatusCode != 404 {
		tflog.Error(ctx, "Unexpected status code from segment deletion", map[string]interface{}{
			"segment_id":  tagbasedpolicyID,
			"status_code": res.StatusCode,
		})
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

	// Log success with status code
	tflog.Info(ctx, "Segment deletion successful", map[string]interface{}{
		"segment_id":  tagbasedpolicyID,
		"status_code": res.StatusCode,
	})
}

func (r *SegmentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Check if the import ID is a UUID (existing behavior) or a name
	if isSegmentUUID(req.ID) {
		// Existing behavior - direct ID import
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
		return
	}

	// If not a UUID, assume it's a name and look up the segment
	// Create a search criteria that filters by the segment name
	searchCriteria := fmt.Sprintf("tagBasedPolicyName = '%s'", req.ID)
	listReq := operations.ListTagBasedPoliciesRequest{
		SearchInput: shared.SearchInput{
			Criteria: searchCriteria,
		},
	}

	// Add debug logging
	tflog.Info(ctx, "Importing segment by name", map[string]interface{}{
		"name":            req.ID,
		"search_criteria": listReq.SearchInput.Criteria,
	})

	// Try to get the segments
	policies, err := r.client.Tagbasedpolicies.ListTagBasedPolicies(ctx, listReq)

	if err != nil {
		resp.Diagnostics.AddError(
			"Error retrieving segments",
			fmt.Sprintf("Could not list segments to find by name: %s", err),
		)
		return
	}

	// Process the JSON response
	if policies.TagBasedPolicies != nil && len(policies.TagBasedPolicies.Items) > 0 {
		// Find the segment with the matching name
		var foundID string
		for _, policy := range policies.TagBasedPolicies.Items {
			if policy.TagBasedPolicyName != nil && *policy.TagBasedPolicyName == req.ID {
				if policy.TagBasedPolicyID != nil {
					foundID = *policy.TagBasedPolicyID
					break
				}
			}
		}

		if foundID != "" {
			tflog.Info(ctx, "Found segment", map[string]interface{}{
				"id":   foundID,
				"name": req.ID,
			})
			resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), foundID)...)
			return
		}
	}

	resp.Diagnostics.AddError(
		"Segment not found",
		fmt.Sprintf("No segment found with name: %s", req.ID),
	)
}

// Helper to check if a string is a UUID
func isSegmentUUID(s string) bool {
	// Simple UUID format check (not comprehensive)
	matched, _ := regexp.MatchString(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, strings.ToLower(s))
	return matched
}
